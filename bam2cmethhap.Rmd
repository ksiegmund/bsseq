---
title: "Call DNAm haplotypes"
author: "Ks"
date: '`r paste("First created on 10/15/2019. Updated on", Sys.Date())`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load Libraries:
```{r libraries, message=FALSE}
library(GenomicAlignments)
library(tidyverse)
library(writexl)
```

# Load annotation

Load target regions, sequences and CpG positions:
```{r readcgpositions}
load("data/cgposafterclip.rda")
load("data/clipgrplus1.rda")
```

Write the clipped target regions to a bed file that I can use for filtering my *.bam files.  The read must cover this entire region for me to read it into memory.
```{r writebed}
bedfl <- cbind.data.frame(seqnames(clipgrplus1),start(clipgrplus1),end(clipgrplus1))
bedfl
write.table(bedfl,file="data/clipgrplus1.bed",sep = "\t",
            row.names = FALSE, col.names = FALSE, quote = FALSE)
```


Filenames for this processing run.
```{r runnames}
#datadir=c("~kims/Google Drive File Stream/My Drive/shibata/methylation bam files 9-19")
#writedatafn=c("~kims/GitHub/runbsseq/data/cmethhaps/darrylsbamfiles9-19")

#datadir=c("~kims/Google Drive File Stream/My Drive/methylation ampliseq bam files 12-19")
#writedatafn=c("~kims/GitHub/newbsseq/data/cmethhaps/experimental-ctls")

datadir=c("~kims/Google Drive File Stream/My Drive/shibata/GalaxyBSbam_6284_6_20")
writedatafn=c("~kims/GitHub/runbsseq/data/cmethhaps/20200620")
```

Read in .bam filenames.
```{r bamfilenames}
bamfiles=dir(datadir,pattern="*\\.bam$")
whichbam <- 55
```

Shorten these filenames for Excel output.
```{r shortenfilenames}
sslist <- strsplit(bamfiles,c("Galaxy"))
snm <- map_chr(sslist, ~.x[1])  
```

Set flags for reading in the data. I will require the mapping quality score is 30 or better.
```{r readGAlign}
#flag0 <- scanBamFlag(isFirstMateRead=TRUE, isSecondMateRead=FALSE,
#                      isDuplicate=FALSE, #isNotPassingQualityControls=FALSE)
#param0 <- ScanBamParam(flag=flag0, what=c("seq","qual"))

flag1 <- scanBamFlag(isFirstMateRead=TRUE, isSecondMateRead=FALSE,
                    isUnmappedQuery=FALSE,isSecondaryAlignment=FALSE,
                    isProperPair=TRUE,isSupplementaryAlignment=FALSE,
                    isNotPassingQualityControls=FALSE)
param1 <- ScanBamParam(which = clipgrplus1,flag=flag1, mapqFilter = 30,
                        what=c("seq","qual"))
```

```{r functions}
# subset gal object to reads covering region
readsonregion <- function(gaobj,region) {
    r1 <- findOverlaps(ranges(gaobj),ranges(region),
                          minoverlap=width(region))
    gal.subset <- gal[queryHits(r1)]
    gal.subset
}    

# clip all the reads to the size of my target (1st to last C(pG)).
clipreads <- function(reads_on_ref,startpos,region){
  
    clipped.start <- start(region) - startpos + 1
    clippedreads <- BStringSet(reads_on_ref, 
                              start=clipped.start, 
                               width=rep(width(region),
                                         length(reads_on_ref)))
    clippedreads
}

# turn nucleotide vector into pattern of 1/0 with 1 = methylated; 0 = unmethylated
dnamhap <- function(seqvec,cpgpos,WCstrand){
          
          if (WCstrand==c("W")) {
              hapbase <- unlist(strsplit(toString(seqvec),split=""))[cpgpos]
              hapvec <- ifelse(hapbase=="C",1,ifelse(hapbase=="T",0,NA))
          }
          else {
              hapbase <- unlist(strsplit(toString(seqvec),split=""))[cpgpos+1]
              hapvec <- ifelse(hapbase=="G",1,ifelse(hapbase=="A",0,NA))
          }
  hapvec
}

# turn these into haplotypes
gethaps <- function(clipgal,thisregion,cpgpos,regiongr,
                    WCstrand=c("W"),maxcpg=19){
  ncpg <- length(cpgpos)
  nreads <- length(clipgal)
  #pad matrix to length of longest c haplotype (19) (improve this later)
  hapmat <- data.frame(matrix(NA,nrow=nreads,ncol=ncpg))
  
  haplst <- lapply(clipgal,dnamhap,cpgpos,WCstrand)
  hapmtx <- matrix(unlist(haplst),byrow=T,ncol=ncpg)
  hapmat[,1:ncpg] <- hapmtx
  colnames(hapmat) <- paste("X",1:ncpg,sep="")
   
  # remove haplotypes with missing data (I can't 'collapse' them)
  if (ncpg>1) {
    filt <- which( apply(is.na(hapmat[,c(1:ncpg)]),1,sum) > 0)
    if (length(filt)>0)
      hapmat <- hapmat[-filt,]
      htype <- apply(hapmat[,(1:ncpg)],1,paste,collapse="")
  }
  else {
    filt <- which(is.na(hapmat[,1]))
    if (length(filt)>0)
      hapmat <- hapmat[-filt,]
    htype <- as.character(hapmat[,1])
  }
  datmat <- cbind.data.frame(sample = snm[whichbam],
                             amplicon = thisregion,
                      chr = seqnames(regiongr),
                      start = start(regiongr),
                      readseq = 1:nrow(hapmat),
                      htype = htype,
                      hapmat)
  datmat
}
```

# DNAm haplotype Pipeline

Now run pipeline for a single sample.  Sorted Bam file + index get saved to local directory. They are deleted after C-methylation haplotype calling. 
```{r sort-index-bam}
start_time <- Sys.time()

sortBam(file.path(datadir,bamfiles)[whichbam],
        paste(snm[whichbam],"sorted",sep="."))
indexBam(paste(snm[whichbam],"sorted.bam",sep="."))
```
 
```{r read-bam} 
gal <- readGAlignments(paste(snm[whichbam],"sorted.bam",sep="."),
              use.names=TRUE, param=param1)
print(paste("# reads input (mapqscore>30 & overlap regions):", length(gal)))
```

```{r run-pipeline}
# create empty list of data frames for each amplicon 
my.names<-paste("amplicon",1:38,sep="")
ldf <- setNames(replicate(38,data.frame()),my.names)

#For each region do the following: 
for (thisregion in 1:38) {
   #Subset to reads that cover single region.
  gal.sub <- readsonregion(gal,clipgrplus1[thisregion])
    if(length(gal.sub)>1) {  # require 2 read minimum to report haplotypes
      qseqs <- mcols(gal.sub)$seq
      # This is to get the sequences aligned to reference with D/Is
      qseq_on_ref <- sequenceLayer(qseqs, cigar(gal.sub))
      clipped.qseq <- clipreads(qseq_on_ref,start(gal.sub),
                              clipgrplus1[thisregion])

      # I will pass strand information to gethaps so I 
      # know whether to adjust the C(pG) position to the (Cp)G position. 
      # If C strand, then use G position; W strand uses C position.
      
      dmat <- gethaps(clipped.qseq,
                      thisregion,
                      cgposafterclip[[thisregion]],
                      clipgrplus1[thisregion],
                WCstrand = values(clipgrplus1)$WC_strand[thisregion])
      ldf[[thisregion]] <- dmat    
    }
}
end_time <- Sys.time()

end_time - start_time
```
 
 is the run time for sample 
```{r samplename}
snm[whichbam]
```

# Read Depths/Region

Here's the read depth for each amplicon.
```{r amplicondepth}
map_int(ldf,nrow)
```

And total read depth:
```{r totreaddepth}
sum(map_int(ldf,nrow))
```

```{r writefiles}
snm2 <- paste(snm,"xlsx",sep=".")
write_xlsx(ldf,file.path(writedatafn,snm2[whichbam]) )

file.remove(paste(snm[whichbam],"sorted.bam",sep="."))
file.remove(paste(snm[whichbam],"sorted.bam.bai",sep="."))
```

# Excel File created:
```{r whichfile}
snm2[whichbam]
```

```{r sessionInfo}
sessionInfo()
```